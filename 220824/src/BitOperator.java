
public class BitOperator {

	public static void main(String[] args) {

		int a= 10, b =12; // 0000 1010
		// 최상위 비트는 부호 비트로 사용되며 0은 양수, 1은 음수
		// 10 = 0 000 1010
		// 12 = 0 000 1100
		
		
		// 비트연산자
		// & : 비트 and, 두 비트가 모두 1이면 1
		// | : 바트 or, 두 비트중에서 1비트 이상 1이면 1
		// ^ : 비트 xor(배타적 논리합), 두 비트가 다를 때 1
		// ~ : 비트 부정, 1은 0으로 0은 1로, 1의 보수를 계산한다.
		
		System.out.println(a & b); // 8
		System.out.println(a | b); // 14
		System.out.println(a ^ b); // 6
		System.out.println(~a); // 1 111 0101
		// 숫자의 크기를 알아보려면 2의 보수로 바꿔야 함 => (1의보수)0000 1010 + 1 => (2의보수)0000 1011
		
		// 9의 보수 : 어떤 수가 있을 때, 수에 얼마를 더해야 그 자리에 꽉 차는 수인가 => 컴퓨터에서 1의 보수라고 부름 0 -> 1, 1 -> 0
		// 10의 보수 : 어떤 수가 있을 떄 그 수에 얼마를 더해야 자리 올림이 발생하는 수인가 => 컴퓨터에서 2의 보수라고 부름
		// 10의 보수는 9의 보수보다 1이 크다. 2의 보수도 1의 보수보다 1이 크다.
		
		// 고정 소수점 : 2진 정수를 표현
		// 고정 소수점 표현 방법은 부호와 절대치, 1의 보수, 2의 보수 이렇게 3가지 방법이 있고, 현재는 2의 보수법만 사용
		// 양수 표현방법은 3가지 방법 모두 같고, 음수 표현방법이 각기 다름
		// 부호와 절대치 : 부호만 1로 변경하고, 나머지는 그대로/ 10 = 0000 1010, -10 = 1000 1010
		// 1의 보수 : 양수를 1의 보수로 변환 / 10 = 0000 1010, -10 = 1111 0101
		// 2의 보수 : 양수를 2의 보수로 변환, 1의 보수 +1 / 10 = 0000 1010, -10 = 1111 0110
		// 2의 보수법을 쓰는 이유 : 0이 하나밖에 없음, 음수를 하나 더 표현 가능
		
		
		
		
		
		
		
		
		
	}

}
